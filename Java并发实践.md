# 线程安全性

**注意考虑安全性的前提是在多个线程间进行共享的变量,不共享的不予考虑**

1. 当多个线程访问一个**可变**的状态变量是没有合适的**同步**,那么程序就可能错误, 修复:

   * 不再线程之间共享该变量
   * 将该状态变量设定为不可变变量
   * 在访问该状态变量时**使用同步**

2. **线程安全类** :

   1. 无状态对象(既没有任何属性)一定时线程安全的

   2. 当类中方法对可变属性做**非原子操作**时,会产生不同步问题, 例如 :

      `i++` : 这个操作可以分为`获取i->修改i->写入i`的操作序列,**并且每一步都依赖于之前的状态**

      对于原子操作不会产生冲突

3. **静态条件** :

   1. **先检查后执行** : 从检查出结果到执行对应的操作的这段时间内,**检查结果就已经失效了!**

   2. 常用情景: 延迟初始化 : 当变量使用时进行初始化

      ​		**当多线程访问时可能会多次初始化,返回不同的值**

4. 复合操作 :

   1. 包含一组以原子操作进行(不可分割)的操作
   2. **线程安全类的符合操作要进行加锁设置**
   3. **可以使用内置的原子变量类来使得单个复合操作转化为原子操作**

5. 加锁机制 : 将复合操作转化为原子操作

   1. 内置锁 : **同步代码块** : 以`synchronized`来修饰的一整个语句块 :

      **加锁的时该关键词所在的对象实例/类(全局锁)**,锁住对象时对该类的其他对象实例没影响

      * **作用** : 使一组语句作为一个不可分割的单元执行(原子性)

      * 注意 : 对`synchronized`修饰的方法 :

        * 一般对其所在的对象加锁
        * **对于静态方法对其所在的类加锁**

      * 机制 : 线程在成功进入同步代码块时自动获得锁,在退出时(无论正常还是异常)释放锁

        **当另一个线程试图进入锁上的对象/类时必须等待/阻塞**(锁的互斥性)

   2. 重入机制 : 一个线程可以再次请求进入自己拥有锁的同步代码块

      **持有锁的是进入的线程,而不是调用**

   3. 用锁来保护状态 :

      * **当一个线程获取与对象关联的锁时,并不能阻止其他线程访问该对象,只是阻止其他线程获取同一个锁,所以注意 :**
        1. 将所有可变状态封装在对象内部
        2. **对对象内部所有访问可变状态的代码路径进行同步**
      * 即:
        1. 当一个线程进入一个对象(类)的同步块时,其他线程不能再进入该同步块
        2. 当一个进程进入一个对象(类)的同步块时,其他线程可以进入其他非同步块或同步块(获得另一种锁)

   4. 加锁会影响并发性能,所以尽可能细粒度的加锁,不需要同步的代码块不要同步

# 对象的共享

1. 可见性保证  ;

   **访问某个共享且可变的变量时要求所有线程在同一个锁上同步**,保证某个线程写入的值确定性的对其他线程可见

   注 ; 编译器会对操作进行重排序,在多线程中不同步的操作甚至同一代码段执行顺序都不同