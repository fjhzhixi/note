# Regular expression

## 通用规则

### 基本匹配

单纯的进行字符的逐个匹配(**这里的字符不能在正则规则中有特殊含义,否则要进行转义才能匹配)**:

```
例如the匹配theme中的the
```

### 元字符匹配

元字符具有特殊的含义

| 元字符  | 特殊含义                                                     |
| :-----: | ------------------------------------------------------------ |
|   `\`   | 转义字符(详见下)                                             |
|   `^`   | 从开始行进行匹配,当正则表达式以`^`开头时表示匹配成功对象必须从字符串开头开始 |
|   `$`   | 从末尾进行匹配,当正则表达式以`$`结尾时表示匹配成功对象必须以字符串结尾结束 |
|   `.`   | 匹配任意单个字符(除了换行符)                                 |
|  `[]`   | 匹配中括号列表中的任意一个字符 `[a-z]表示范围内的任何一个字符` |
| `[^ ]`  | 匹配除了括号中字符之外的任何一个字符                         |
|   `*`   | 匹配0次或者大于0的任意次前一个字符(**或者前一个子正则表达式**) |
|   `+`   | 匹配1次或者大于1的任意词前一个字符(**或者前一个子正则表达式**) |
|   `?`   | 匹配0次或者1次前一个字符(**或者前一个子正则表达式**)         |
| `{n,m}` | 匹配num(`n<=num<=m)`次前一个字符(**或者前一个子正则表达式**)*n缺省时为0,m缺省时为无穷大* |
| `(xyz)` | 匹配`()`中的表达式(**用小括号来构造局部的子正则表达式**)     |
|   `|`   | 正则表达式的或逻辑,任意匹配一个即可(**注意在前面的子正则表达式优先匹配**) |

注 : 

* 在Java中`\\`其转义作用

  1. 使用`\\`表示某些特殊字符的含义[简写字符集]*(当这些字母单独出现时表示匹配自己对应的字母*)

     * `\\d`匹配数字字符`0 - 9`	`\\D`匹配非数字字符

     * `\\n`匹配换行符

     * `\\s`匹配任何空白字符           `\\S`匹配任何非空白符

       .......

  2. 使用`\\`可以使某些具有特殊含义的字符匹配自己本身对应的字符**(*当他们单独出现时在正则表达式中有特殊的含义*)

     * 特殊字符有`[]  ()  {}  .   *   +   ?    ^   $   \   |`等
     * 例如要匹配字符串`()`,Java正则表达式就要为`\\(\\)`

* **使用`^`[reg_exp] `$`形式的正则表达式必须匹配整个字符串才算匹配成功**

  Java中的``String.match(reg, str)``方法默认会在reg加上`^`与`$`所以可以不写

### 前后关联约束

1. 前置约束-存在  `?=....`

   `Reg(?=ConstraintReg)` : 表示匹配Reg表达式但是其后必须存在ConstraintReg表达式的匹配项

   `[tT]he(?=\sfat) =>`**`The`** `fat car sat on the mat`

2. 前置约束-排除 `?!....`

   `Reg(?!ConstrainReg)` :  表示匹配Reg表达式但是其后必须不存在ConstraintReg表达式的匹配项

   `[tT]he(?=\sfat) => ` `The fat car sat on`**`the`** `mat`

3. 后置约束-存在`?<=....`

   `(?<=ConstraintReg)Reg`: 表示匹配Reg表达式之前必须匹配ConstraintReg表达式

4. 后置约束-排除`?<!....`

   `(?<!ConstraintReg)Reg`: 表示匹配Reg表达式之前必须不匹配ConstraintReg表达式

### 标记

* 标记`i`忽略大小写
* 标记`g`进行全局搜索,返回所用成功匹配的串
* 标记`?`表示非贪心匹配,对前面紧接的多种可能的规则匹配最短的可能(默认为贪心的  : 匹配所有可能中最长的)

## Java相关类

**Pattern 与 Matcher类**

### 标准使用

在`str`中寻找`reg`正则表达式的匹配

在正则表达式中,按照`()`从左向右进行分组,0组默认为整个正则表达式

```java
Pattern pattern = Pattern.compile(reg);
Matcher matcher = pattern.matcher(str);
while(matcher.find()) {
    String hit = matcher.group();
}
```

### 注意事项

* 在`compile(reg)`中`reg`必须在最外侧用一个`()`包括,表示一个单独的捕获组

  **matcher从开始到结尾扫描字符串,每次返回一次的匹配结果**

* 每次执行`find()`都执行一次匹配操作,成功则返回`true`,并更新每个`group`匹配到的信息

* `matcher`提供`start()与end()`方法返回每次匹配的位置

## 正则表达式匹配工作原理

### 正则表达式引擎

* `DFA` : 确定型有穷自动机,以文本为主导,从左向右匹配文本,不会对一个字符匹配多次,支持的特性少,但是快
* `NFA` :  不确定型有穷自动机,以正则表达式为主导,存在对文本字符的读入吐出等操作,一个字符可能匹配多起,**回溯过程**使得速度较慢,但是支持捕获组等特性

**`DFA`匹配效率与正则表达式的写法无关,但是`NFA`对不同的表达式的效率不同,可能因为回溯过长爆栈(正则表达式底层实现式通过递归,所以在递归层数过多可能就会爆栈)**

### 正则表达式3种模式

* 贪婪模式(默认) : 尽可能匹配最长的字符 (在这个过程中要不断的尝试,失败后要进行回溯)
* 懒惰模式(在`* + ?`等后加`?`) : 尽可能少的匹配重复字符,若匹配成功则继续向下匹配
* 独占模式(加上`+`) : 尽可能匹配最长的字符,在失败之后不进行回溯而结束匹配而不会回溯

**使用贪婪模式和懒惰模式只是匹配的长短的区别,但是都能匹配到符合正则表达式结构的字符串,但是使用独占模式时一定要注意可能匹配不到,因为他不会回溯,在贪婪模式下一路走下去,若不匹配不会回溯而是直接结束,返回匹配失败**

### Java中优化正则表达式性能

**滥用`* . ? +`是不环保的行为**

* 尽可能使用`pattern.complie(regx)`进行预编译
* 尽量少用`(X|Y|Z)`的形式,或者`X, Y, Z`尽可能短,从中提取相同的元素放在外面
* 减少分组和嵌套,如果不需要该分组的文本只需要判断是否匹配则使用非捕获形式`(?:expression)`
* 尽量较少贪婪匹配的形式
* 选择出现最多的字符串形式放在或逻辑的最前面.避免回溯