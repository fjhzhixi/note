# Regular expression

## 通用规则

### 基本匹配

单纯的进行字符的逐个匹配(**这里的字符不能在正则规则中有特殊含义,否则要进行转义才能匹配)**:

```
例如the匹配theme中的the
```

### 元字符匹配

元字符具有特殊的含义

| 元字符  | 特殊含义                                                     |
| :-----: | ------------------------------------------------------------ |
|   `\`   | 转义字符(详见下)                                             |
|   `^`   | 从开始行进行匹配,当正则表达式以`^`开头时表示匹配成功对象必须从字符串开头开始 |
|   `$`   | 从末尾进行匹配,当正则表达式以`$`结尾时表示匹配成功对象必须以字符串结尾结束 |
|   `.`   | 匹配任意单个字符(除了换行符)                                 |
|  `[]`   | 匹配中括号列表中的任意一个字符 `[a-z]表示范围内的任何一个字符` |
| `[^ ]`  | 匹配除了括号中字符之外的任何一个字符                         |
|   `*`   | 匹配0次或者大于0的任意次前一个字符(**或者前一个子正则表达式**) |
|   `+`   | 匹配1次或者大于1的任意词前一个字符(**或者前一个子正则表达式**) |
|   `?`   | 匹配0次或者1次前一个字符(**或者前一个子正则表达式**)         |
| `{n,m}` | 匹配num(`n<=num<=m)`次前一个字符(**或者前一个子正则表达式**)*n缺省时为0,m缺省时为无穷大* |
| `(xyz)` | 匹配`()`中的表达式(**用小括号来构造局部的子正则表达式**)     |
|   `|`   | 正则表达式的或逻辑,任意匹配一个即可(**注意在前面的子正则表达式优先匹配**) |

注 : 

* 在Java中`\\`其转义作用

  1. 使用`\\`表示某些特殊字符的含义[简写字符集]*(当这些字母单独出现时表示匹配自己对应的字母*)

     * `\\d`匹配数字字符`0 - 9`	`\\D`匹配非数字字符

     * `\\n`匹配换行符

     * `\\s`匹配任何空白字符           `\\S`匹配任何非空白符

       .......

  2. 使用`\\`可以使某些具有特殊含义的字符匹配自己本身对应的字符**(*当他们单独出现时在正则表达式中有特殊的含义*)

     * 特殊字符有`[]  ()  {}  .   *   +   ?    ^   $   \   |`等
     * 例如要匹配字符串`()`,Java正则表达式就要为`\\(\\)`

* **使用`^`[reg_exp] `$`形式的正则表达式必须匹配整个字符串才算匹配成功**

  Java中的``String.match(reg, str)``方法默认会在reg加上`^`与`$`所以可以不写

### 前后关联约束

1. 前置约束-存在  `?=....`

   `Reg(?=ConstraintReg)` : 表示匹配Reg表达式但是其后必须存在ConstraintReg表达式的匹配项

   `[tT]he(?=\sfat) =>`**`The`** `fat car sat on the mat`

2. 前置约束-排除 `?!....`

   `Reg(?!ConstrainReg)` :  表示匹配Reg表达式但是其后必须不存在ConstraintReg表达式的匹配项

   `[tT]he(?=\sfat) => ` `The fat car sat on`**`the`** `mat`

3. 后置约束-存在`?<=....`

   `(?<=ConstraintReg)Reg`: 表示匹配Reg表达式之前必须匹配ConstraintReg表达式

4. 后置约束-排除`?<!....`

   `(?<!ConstraintReg)Reg`: 表示匹配Reg表达式之前必须不匹配ConstraintReg表达式

### 标记

* 标记`i`忽略大小写
* 标记`g`进行全局搜索,返回所用成功匹配的串
* 标记`?`表示非贪心匹配,对前面紧接的多种可能的规则匹配最短的可能(默认为贪心的  : 匹配所有可能中最长的)

## Java相关类

**Pattern 与 Matcher类**

### 标准使用

在`str`中寻找`reg`正则表达式的匹配

```java
Pattern pattern = Pattern.compile(reg);
Matcher matcher = pattern.matcher(str);
while(matcher.find()) {
    String hit = matcher.group();
}
```

### 注意事项

* 在`compile(reg)`中`reg`必须在最外侧用一个`()`包括,表示一个单独的捕获组

  **matcher从开始到结尾扫描字符串,每次返回一次的匹配结果**

* `matcher`提供`start()与end()`方法返回每次匹配的位置