# 第一节课

**类中数据和方法默认是私有的**

## overloading(重载机制)

1. 相同函数名,有不同的参数列表的函数可以共存

   ```C++
   void add(int a, int b);
   void add(int a)
   ```

2. **不能通过返回值类型来区分同名函数**

## 宏(define)

1. 宏的本质是在编译的时候进行替换

2. 宏的类型

   1. 常量宏:常用常量赋予意义

      `define PI 3.1415`

   2. 函数宏:实现简单的函数功能

      `define ADD(a, b) (a + b)`

   3. 控制宏:开关

      ```C++
      #define REMOTE_VER
      int main(){
          #ifdef RENOTE_VER
          	cout << "connect oracle" << "\n";
          #else
          	cout << "connext mysql" << "\n";
          #endif
      }
      ```

      在上述代码中有第一行的define时输出"connect oracle"

      没有第一行的define时输出"connect mysql"

      **这种技巧可以用在区分debug模式和实际功能模式**

## 缺省参数

1. 参数列表中的参数值可以在定义时设置为默认值在调用时可以选择不传递而使用默认值

2. **设置为缺省值的参数必须在参数列表的最后面(即先声明未设置默认的参数)**

   `int add(int a, int b, int c = 10, int b = 4)`

3. 一般在C++项目中.h文件中会声明函数(不进行实现),宏定义,全局变量,结构定义等

   一般设置缺省参数值在.h中的声明时实现,**此时不能再在.cpp文件中实现时重复声明,一般通过注释提示**

   ```c++
   // 在.h头文件中
   int add(int a, int b = 10);	// 只声明函数而不进行具体实现
   // 在.cpp文件中
   int add(int a, int b/* =10 */){
       // 具体实现
   }
   ```

   

## 占位

类似于`void add(int)`这种函数的定义是合法的,在传入参数时也必须传入一个int值,但是这个值一定无法被使用

## 头文件结构

1. 避免在一个文件中对同一个头文件进行重复包含,**因为同文件之间也可能相互包含,所以这种情况很容易发生**

   所以在编写头文件时有标准的结构要求

   ```c++
   #ifndef HEADFILE_NAME	// 一般与头文件名字保持一致
   #define HEADFILE_NAME
   // 具体内容
   #endif
   ```


# 第二节课

## C与C++混合编译

工程时生成可执行文件时先编译,再链接

LNK型错误时链接错误 : 链接时依赖的是经过编译修饰之后的函数名,C++函数的修饰和C函数的修饰方法不同,所以在C++中直接调用C函数会发生链接错误,使用之下的语句在C++文件中声明避免

**核心时通过`.h`的条件编译实现**

`extern ‘C’ 函数名`

在C++中兼容C头文件的原理:`.h`文件的规范:

```C++
#ifdef __cplusplus
extend "C" {
#endif
函数声明;
}
```

## 库文件

通过编译生成,可供人根据`.h`中的定义调用函数,而避免源代码的泄露

* 动态库:`.dll`文件

* 静态库: `.lib`文件

  **区别在于是否参与原程序的生成,动态库不会包含,静态库要包含,即静态库会包含在生成的可执行文件,而动态库不会,程序运行需要外部支持**

导入自己的库:

1. 将库文件导入到自己的工程文件夹
2. `#pragma comment(lib, "lib_name ")`加入到文件头,形成链接

## 面向对象

`class`内部默认私有,`strcut`内部默认共有

1. 类的构造:

   **从本质来看,对象是一片连续的内存空间,可以利用C++保留指针的特性进行非法操作**

   可以通过在`.lib`库中定义类.在外部属性只定义一个属性:是库中的类的实例对象的指针

   * 属性 : 包含变量,占据执行区域的栈区内存

   * 方法 : 包含对对象的操作,占据加载程序时的空间,函数不占有运行期空间

     1. 构造方法 : 初始化生成对象实例

     2. set-get方法 : 和可见性修饰一起对类的属性进行访问控制

        ```C++
        class Student{
            private:{
            	int age;
            	char* name;
            };
            public: {
            	void init(int age, char* name, Student* s);
                int getAge();
                void setAge(int age);
            };
            void Student::init(int age, char* name, Student* s){
              // statement;  
            }
            int Student::getAge(){
                return age;
            }
            void Student::setAge(int age){
               // statements
        		}
            }
        }
        ```

        

   注 : 结构体的属性的存储方式时按最大数据类型的大小进行对齐,按**运行顺序**进行空间分配

   ```C++
   struct{
       int i;		// 分配4字节
       int j;		// 分配4字节
       char c;		// 分配4字节,占据1字节
       char d;		// 在剩下的3字节中占据1字节
   };
   ```


# 第三节课

##  构造函数

1. 无返回值,在每次建立对象时使用,与类同名,没有返回值

   ```C++
   Student::Student(int  aage, char *nname) {
       age = aage;
       name = nname;
   }
   ```

2. 对象放在堆区存储(使用`new`创建的对象),局部基本变量放在栈区

3. 对象声明:

   * `Student s`;
   * `Student s = new Student();`

4. 对象中对象的存储有两种形式:

   1. 直接定义对象 : 必然占有空间,一般用必然存在的内部对象
   2. 定义对象句柄 : 只占据4字节指针空间,使用时通过动态分配,一般用于不一定存在的对象

5. 清理不用对象释放内存

   `~Test()` : // 析构函数

   该函数的作用在对象消亡时(**对象指针在栈区,当出作用域时出栈消亡**)释放对象数据域中的指针所指向的空间避免内存泄露

   1. 构造函数至少有一个(默认构造),可以有多个

      而析构函数至多只有一个,因为其没有参数,所有不可能重载

      **构造方法可以有多种,但是析构函数只有一种**,所以在不同参数的构造函数当不对数据域指针操作时将其**设置为NULL**,防止在析构函数中**释放野指针报错**

      ```C++
      Test {
          int i;
          int *j;
      }
      Test::Test(int i, int *j) {
          this.i = i;
          this.j = j;
      }
      Test::Test(int i) {
          this.i = i;
          this.j = NULL;		// 防止对j释放时操作野指针报错
      }
      Test::~Test() {
          delete j;		// 要保证调用所有的构造方法时指针j一定被初始化,不能使野指针
      }
      ```

   2. 构造函数中有`new`操作(即数据域有指针,构造中申请堆上动态空间),必须实现析构方法

   3. 析构方法**释放的是对象中的所有申请的堆上的动态空间**,不只是在构造函数中申请的空间

      1. `delete p`函数是将指针`p`指向的堆区空间释放,栈区的指针`p`本身并没有改变

6. **一个对象的逻辑属性一定存在与其数据域中,而数据域不一定只包含逻辑属性,还可以包含用于类中函数沟通的变量工具 : 例如标记一个函数是否被调用的flag变量**

# 第四节课

## 引用(reference)

引用是一个安全的指针(可以看作对**相同变量的不同命名**), **引用必须在定义时初始化,并且初始化之后不能再改变引用对象,是永久绑定问题**

1. 引用可以取代通过指针改变参数值的操作

   ```C++
   void fun1(int *i) {
       (*i)++;
   }
   void fun2(int &i) {		// 当函数以引用作为参数时,传参时将引用绑定参数
       i++;
   }
   int main() {
       int m = 10;
       fun1(&m);	// fun1传入m的地址,即指针
       fun2(m);	// fun2传入m
       // 两个函数运行之后m值都是11
   }
   ```

2. 类中隐含存在的不只是默认构造

   还有**拷贝构造** : 即以自身同类型的自身实例作为参数的构造方法,其实现是对参数进行**浅拷贝**形成一个新的对象

   **拷贝构造的传入一般设置为`const`类型的指针**

   深拷贝与浅拷贝 : 

   * 浅拷贝 : 按位拷贝,即拷贝对象数域中的每个字节,**当数据域中有指针时浅拷贝大概率会出错**

   * 深拷贝: 逻辑拷贝,要显式的编写

     ```C++
     Test {
         int i;
         int *j;
     }
     Test::Test(int i, int j) {
         this.i = i;
         this.j = &j;
     }
     Test::~Test() {
         delete j;
     }
     int main() {
         Test t1(1, 2);
         Test t2(t1);	//默认浅拷贝,所以t2.j与t1.j指向同一个地址
     }
     // 当main函数结束时从栈中局部变量弹出消亡,先弹出t2,执行t2的析构函数释放j指向空间
     // 之后弹出t1,执行析构函数,对j指向的同一地址二次释放会崩溃
     
     // 显式的深拷贝
     Test::Test(const Test &t) {
         this.i = t.i;
         this.j = new int(*(t.j));
     }
     ```

3. 指针的错误 :

   * 访问/释放野指针
   * 对同一内存区域重复释放
   * 不同指针指向同一地址(浅拷贝导致)
   * 返回局部变量地址
   * 不及时清理堆上空间导致内存泄漏

4. C/C++`是一次编写,跨平台编译,之后运行

   `java`是一次编译,在任何平台的Java虚拟机上运行,`java`天生带有跨平台特性

# 第五节课

**对参数传递对象一定不要传值(never pass by value)**

## 可见周期/生存周期

1. `static` : 

   * 修饰变量 : 静态变量在局部定义时,其可见域是该局部区域,但是其生存周期是整个程序的运行期

     **静态(局部)变量的存储位置是在全局变量处的,而不在栈区**

     静态局部变量只建立一次,在第一次被使用时建立,在程序运行结束之后消亡

     全局变量在执行函数之前就建立.

   * 修饰函数 : 静态函数默认只能在本文件中使用,一般是一些本文件的功能函数,不允许其他文件调用

     一般函数默认的使用域为全体文件,只需在使用前显示声明即可(**函数默认外连接**)

   * 类中使用 : 

     * 修饰属性 : 静态属性属于类的全体对象,所有对象共享一块内存区域

       **其初始化不应该在构造函数中,而应该在函数外以全局变量的形式初始化**

       **静态的类中属性可以用于实现同一类的所有对象的通信**

     * 修饰方法 : 静态方法可以不通过实例化对象调用,可以直接通过类名来调用

       **这种方法常用于方法返回值与对象属性无关(即不依赖于实例对象)或者一些功能性的函数**

2. 全局变量

   * 全局变量一定在某个源文件中定义,**不能在头文件中定义**(否则头文件被多个源文件包含时会有重复定义)
   * **全局变量默认只能在定义它的源文件中使用**,在其他处使用`extern type elem`显式声明外链接

3. `namespace`:

   * 使用场景 : 当不同的头文件中定义重名时在同一文件包含用来区分同名

   * 实现 : 在`.h`文件中定义名空间,在源文件中使用名空间

     ```c
     // 在H1.h中
     #ifndef _H1_
     #define _H1_
     
     namespace T1 {
         Class name{
             
         }
     }
     #endif
     
     // 在C1.c中
     #include<H1.h>
     int main() {
         T1::name();
     }
     ```

4. `const`

   * 注意在和指针同时使用时注意顶层`const`与底层`const`的区别

   * `const`修饰的地址参数一定是在函数中是输入(**只读**),不进行改变

   * `const`在函数名之后修饰可以声明常量对象可调用的方法(**该函数不能对对象有所改变**),常量对象不能调用其他方法

     ```c++
     class Obj {
         int i;
     public :
         int get_i() const {
             return i;
         }
     }
     
     int main() {
         const Obj obj;
         obj.get_i();
     }
     ```

# 第六节课

## 单例模式的实现

使得一个类只允许声明一个实例对象

1. 构造方法私有,防止外部调用
2. 类内部维护一个静态方法来返回唯一实例,**通过类名调用获取唯一对象实例**
3. **该对象实例只有在第一次调用获取静态方法时实例化创建唯一对象**

```c++
class Obj{
    Obj(){}		// 私有构造方法
    static Obj *self = NULL;	// 唯一实例对象指针
public :
    static Obj *get_instance() {	// 获取唯一对象函数
        if (self == NULL) {
            self = new Obj();
        }
        return self;
    }   
}
```

## 运算符重载

对已有的运算符赋予新的含义

```c++
class Account {
    int balance;
public :
    Account();
    Account operator+(int money) {		// 对+进行重载,表示向账户中存钱
        balance += money;
        return *this;
    }
}

int main() {
    Account a;
    a = a + 100;
}
```

**重载的核心在于符合人的逻辑,例如字符串的+重载为字符串拼接操作**

## `new - delete   vs   malloc - free`

* 使用`malloc - free` : 
  1. 预先不知道所需内存大小 : 例如链表的构建
* 使用`new - delete` : 
  1. 动态分配人为控制声明周期
* **`new = malloc + constructor(构造方法)`**
  1. 即`new`操作是在先在堆区分配空间,再调用构造方法
* **`delete = destructor(析构函数) + free`**
  1. 即`delete`操作是先调用析构函数,再释放堆中的动态空间
* 使用核心在于两对成对操作.

## 继承

1. `C++`中继承语法

   ```c++
   class FatherObj{			// 所有子类的共性
   public :
       void doSomething(){
           /*
           code in common
           */
       }
   }
   class SonObj : FatherObj {			// 特性
   public :
       void doSomething() {
           FatherObj::doSomething();	// 实现共同的行为
           /*
           code in special
           */
       }
   }
   ```


# 第7节课

## 继承

1. 重定义 : 子类重载与父类完全相同的方法,即相同的函数名称,相同的参数列表

   ​		**一般按逻辑来说子类重定义方法的首先就要调用父类的方法,这是父子类关系决定的**

2. **创建子类对象必然先调用父类的构造方法**

   **子类消亡时先调用自己的析构函数,再调用父类的析构函数**

   二者顺序时相反的

3. **能传递父类参数的一定可以传递子类参数,所以在定义参数时尽可能的抽象**

### 成员函数与继承

1. 父类将他的成员函数分为两类 :

   * 希望子类直接继承不要改变的函数
   * **希望子类根据自身特点自行覆盖的函数,即虚函数,使用`virtual`关键字来声明**

   注 : **当使用指针或引用来调用虚函数时该调用被动态绑定根据具体类型来执行**

2. 任何构造函数之外的非静态函数都可以是虚函数

### 访问控制与继承

* 子类继承父类的成员,但是不一定有权访问,可以访问公有的,不能访问私有的
* `protected`关键词可以使得子类可以访问父类中成员

### 定义子类

使用**类派生列表**

C++支持继承多个父类,但是最好不要调用

```c++
class son : public father {    
}
```

### 子类的组成

**一个子类对象包含多个组成部分** :

* 一个含有自己定义的非静态成员的子对象
* 一个与该子类继承的父类对应的子对象

即子类对象中含有与父类对应的组成部分,如果不显式的在子类的构造方法中调用父类的构造方法,则会调用父类的默认构造方法

### 继承与静态成员

如果一个父类定义了一个静态成员,则在整个继承体系中不敢继承了多少层,**该静态成员只存在唯一的实例**

### 防止继承发生

使用`final`关键词定义类表示其不能被继承

# 第七节课

1. 纯虚函数

   ```c++
   virtual void pure_virtual_function() = 0;
   ```

   **当一个类中有纯虚函数时该类就是抽象类,抽象类不允许实例化**

   纯虚函数也允许有函数结构体

   抽象类的所有子类要想可以实例化必须实现纯虚函数,如果不实现则该子类仍是抽象类

2. 不同类家族之间的关系

   具有共同的功能但是自身在不同的类的继承树中的情况 : **使用接口的机制**

   在`c++`中允许多继承,所以接口本质上就是一个**所有方法都是纯虚函数的抽象类**

   在使用这个共有功能时传入的参数是**这个接口的抽象类型**

   **接口的本质是依赖于行为共性而关联不同家族树上的类,注意,由于其依赖的是行为(即方法),所以设计接口时接口不应该有任何数据成员属性**

   ```c++
   class Bird : class Animal
   {
       public:
       void fly(){}
   }
   class Airplane : class Machine
   {
       public:
       void fly(){}
   }
   class FlyObject
   {
       public:
       virtual void fly(){}
   }
   class radar
   {
       public:
       void findFlyObject(FlyObject f){}
   }
   ```

3. 构造析构于多态
   1. 构造函数一定没有多态机制,即构造函数一定不会被`virtual`修饰

   2. 父类的析构函数要支持多态性,否则当参数为父类类型,但是传递进入的是子类类型时可能只调用了父类的析构函数,但是没有调用子类的析构函数,导致内存少泄露

      **所以好的原则是习惯性的将析构函数设置为虚函数**

      ```c++
      class Farher
      {
          public:
      	Father();
          virtual ~Father(){
              cout << "father die" << endl;
          }
      }
      class Son
      {
          public:
      	Son();
          virtual ~Son(){
              cout << "son die" << endl;
          }
      }
      ```

4. 多态一般不用于静态函数,因为**多态保证的行为的正确性,而静态方法与对象本身无关,所以不用使用多态**

5. 栈的数据结构 : **支持泛型的数据结构**,不关心栈中存储的具体数据类型

   ```c++
   template <class T>	//该类是一个模板类
   class Stack<>
   {
       T stack[100];
       int top;
       public:
       	Stack()
       	void push(T elem){}
       	T pop(){}
   }
   //使用时
   Stack<int> stack_int;
   stack_int.push(3)
   Stack<float> stack_float;
   stack_float.puhs(3.2)
   ```

   泛型支持万能容器的构造

   **万能容器实现在`stl`标准库中,其中的类均是标准模板库**

   1. 万能容器
      1. `vector` : 模仿的是动态数组,所以要求地址空间是连续的,**所以当加入的对象多于数组大小是数组会搬家,即进一次整体的拷贝,寻找一个更大的连续空间**
      2. `list` : 模仿的是链表,其中元素的存储是离散的
   2. 动态增长

6. 迭代器 :

   迭代器是个类,`stl`中的所有容器都要支持`begin() & end()`两个方法

   ```c++
   vector<int> vi;
   vector<int>::iterator it = vi.begin();
   while(it != vi.end) {
       cout << *it << endl;
       // do something
       it++;
   }
   //迭代器通过重载运算符(++/*等等)来将自己的行为伪装成一个指针
   ```

   