# 第一节课

**类中数据和方法默认是私有的**

## overloading(重载机制)

1. 相同函数名,有不同的参数列表(可以是参数的类型不同,也可以是参数的数量不同)的函数可以共存

   ```C++
   void add(int a, int b);
   void add(int a)
   ```

2. **不能通过返回值类型来区分同名函数**

3. 重载机制是一种静态的多态机制

4. **重载的实现原理是在编译时进行函数的重命名,重命名规则取决于编译器**

5. 在c语言中不支持函数重载,是因为c语言的函数重命名只在函数前添加_

## 宏(define)

1. 宏的本质是在编译的时候进行替换

2. 宏定义的末尾不加`;`

3. 宏定义的作用域是在其之后的程序,所以一般声明在文件的最开始

4. 宏的类型

   1. 常量宏:常用常量赋予意义

      `define PI 3.1415`

   2. 函数宏:实现简单的函数功能(只是在编译时进行替换,在运行时才进行计算

      `define ADD(a, b) ((a) + (b))`

      * 当参数是表达式或者宏函数作为一个表达式时可能会有问题,所以定义时括号防患于未然

      * 在定义时要换行在行末要加`\`
      * 参数是直接替换的,参数`#ARGU`会被认为为字符串,会被替换成使用时传入的`"argu"`(带引号)
      * `##`被称为连接符,用来将两个`Token`连接为一个`Token`,注意这里连接的对象是`Token`就行，而不一定是宏的变量.
      * 使用`do-while(0)`使得整个宏定义为一体,在调用时不用考虑

   3. 控制宏:开关

      ```C++
      #define REMOTE_VER
      int main(){
          #ifdef RENOTE_VER
          	cout << "connect oracle" << "\n";
          #else
          	cout << "connext mysql" << "\n";
          #endif
      }
      ```

      在上述代码中有第一行的define时输出"connect oracle"

      没有第一行的define时输出"connect mysql"

      **这种技巧可以用在区分debug模式和实际功能模式**

## 缺省参数

1. 参数列表中的参数值可以在定义时设置为默认值在调用时可以选择不传递而使用默认值

2. **设置为缺省值的参数必须在参数列表的最后面(即先声明未设置默认的参数)**

   `int add(int a, int b, int c = 10, int b = 4)`

3. 一般在C++项目中.h文件中会声明函数(不进行实现),宏定义,全局变量,结构定义等

   一般设置缺省参数值在.h中的声明时实现,**此时不能再在.cpp文件中实现时重复声明,一般通过注释提示**

   ```c++
   // 在.h头文件中
   int add(int a, int b = 10);	// 只声明函数而不进行具体实现
   // 在.cpp文件中
   int add(int a, int b/* =10 */){
       // 具体实现
   }
   ```


## 占位

类似于`void add(int)`这种函数的定义是合法的,在传入参数时也必须传入一个int值,但是这个值一定无法被使用

* 占位参数只有类型声明,而没有参数名声明
* 占位参数也一定在一般参数后面声明
* 占位参数由于没有参数名所以无法在函数内部使用

使用原因 :

1. 可扩展性
2. 兼容`C`写法 :
   * 在`C`中,`void func()`声明表示可以接受任何参数,`void func(void)`表示不接受参数
   * 在`C++`中,`void func()`和`void func(void)`都表示不接受任何参数

## 头文件结构

1. 避免在一个文件中对同一个头文件进行重复包含,**因为同文件之间也可能相互包含,所以这种情况很容易发生**

   所以在编写头文件时有标准的结构要求

   ```c++
   #ifndef HEADFILE_NAME	// 一般与头文件名字保持一致
   #define HEADFILE_NAME
   // 具体内容
   #endif
   ```


# 第二节课

## C与C++混合编译

工程时生成可执行文件时先编译,再链接

LNK型错误时链接错误 : 链接时依赖的是经过编译修饰之后的函数名,C++函数的修饰和C函数的修饰方法不同,所以在C++中直接调用C函数会发生链接错误,使用之下的语句在C++文件中声明避免

**核心时通过`.h`的条件编译实现**

`extern ‘C’ 函数名`

在C++中兼容C头文件的原理:`.h`文件的规范:

```C++
#ifdef __cplusplus	//如果当前编译器是C++编译器
extend "C" {	//告诉编译器这个函数是由C函数写成的,在编译时不要修改函数名
#endif
函数声明;
#ifdef __cplusplus //与上文匹配
}
#endif
```

## 库文件

通过编译生成,可供人根据`.h`中的定义调用函数,而避免源代码的泄露

* 动态库:`.dll`文件

* 静态库: `.lib`文件

  **区别在于是否参与原程序的生成,动态库不会包含,静态库要包含,即静态库会包含在生成的可执行文件,而动态库不会,程序运行需要外部支持**

导入自己的库:

1. 将库文件导入到自己的工程文件夹
2. `#pragma comment(lib, "lib_name ")`加入到文件头,形成链接

## 面向对象

`class`内部默认私有,`strcut`内部默认公有

1. 类的构造:

   **从本质来看,对象是一片连续的内存空间,可以利用C++保留指针的特性进行非法操作**

   可以通过在`.lib`库中定义类.在外部属性只定义一个属性:是库中的类的实例对象的指针

   * 属性 : 包含变量,占据执行区域的栈区内存

   * 方法 : 包含对对象的操作,占据加载程序时的空间,函数不占有运行期空间

     1. 构造方法 : 初始化生成对象实例

     2. set-get方法 : 和可见性修饰一起对类的属性进行访问控制

        ```C++
        class Student{
            private:
            	int age;
            	char* name;
            public:
            	void init(int age, char* name, Student* s);
                int getAge();
                void setAge(int age);
            void Student::init(int age, char* name, Student* s){
              // statement;  
            }
            int Student::getAge(){
                return age;
            }
            void Student::setAge(int age){
               // statements
        		}
            }
        }
        ```
        
        

   注 : 结构体的属性的存储方式时按最大数据类型的大小进行对齐,按**运行顺序(即出现的先后顺序)**进行空间分配

   ```C++
struct{
       int i;		// 分配4字节
       int j;		// 分配4字节
       char c;		// 分配4字节,占据1字节
       char d;		// 在剩下的3字节中占据1字节
   };
   ```


# 第三节课

##  构造函数

1. 无返回值,在每次建立对象时使用,与类同名,没有返回值

   ```C++
   Student::Student(int  aage, char *nname) {
       age = aage;
       name = nname;
   }
   ```

2. 对象放在堆区存储(使用`new`创建的对象),局部基本变量放在栈区

3. 对象声明:

   * `Student s()`; 
     1. 此时的对象s放在栈中
     2. 此时调用的一定是**构造函数种类根据参数决定**
     3. 此时`s`为一个对象,调用函数时使用`s.funct()`
   * `Student *s = new Student();` **更常用的形式**
     1. 此时的对象s放在堆中
     2. 栈中只有指向对象的指针s,此时的构造函数由参数决定
     3. 此时`s`为一个对象的指针,调用函数时使用`s->funct`

4. 对象中对象的存储有两种形式:

   1. 直接定义对象 : 必然占有空间,一般用必然存在的内部对象
   2. 定义对象句柄 : 只占据4字节指针空间,使用时通过动态分配,一般用于不一定存在的对象

5. 清理不用对象释放内存

   `~Test()` : // 析构函数,

   **析构函数针对的是通过`new`创建的对象,因为直接声明的对象本来就在栈区,在退出时自然消亡**

   该函数的作用在对象消亡时(**对象在栈区,当出作用域时出栈消亡**)释放对象数据域中的指针所指向的空间避免内存泄露

   1. 构造函数至少有一个(默认构造),可以有多个

      而析构函数至多只有一个,因为其没有参数,所有不可能重载

      **构造方法可以有多种,但是析构函数只有一种**,所以在不同参数的构造函数当不对数据域指针操作时将其**设置为NULL**,防止在析构函数中**释放野指针报错**

      ```C++
      Test {
          int i;
          int *j;
      }
      Test::Test(int i, int *j) {
          this.i = i;
          this.j = j;
      }
      Test::Test(int i) {
          this.i = i;
          this.j = NULL;		// 防止对j释放时操作野指针报错
      }
      Test::~Test() {
          delete j;		// 要保证调用所有的构造方法时指针j一定被初始化,不能使野指针
      }
      ```

   2. 构造函数中有`new`操作(即数据域有指针,构造中申请堆上动态空间),必须实现析构方法

   3. 析构方法**释放的是对象中的所有申请的堆上的动态空间**,不只是在构造函数中申请的空间

      1. `delete p`操作是将指针`p`指向的堆区空间释放,栈区的指针`p`本身并没有改变

   4. **析构函数的调用场景**

      * 当对象存储在栈区,即**使用`Sudent s()`定义时**,当**出该对象(局部变量)的作用域时自动调用析构函数使对象消亡**
      * 当对象存储在堆区,对象指针在栈区,即**使用`Student s = new Student()`定义时,不会自动调用析构函数,要在代码中显式使用`delete`来触发析构函数,并且在析构函数执行完之后也会释放对象指针指向的对象在堆中空间**
      * **`new`与`delete`一定要成对出现**

6. **一个对象的逻辑属性一定存在与其数据域中,而数据域不一定只包含逻辑属性,还可以包含用于类中函数沟通的变量工具 : 例如标记一个函数是否被调用的flag变量**

7. **`new`与`delete`一定要成对出现**

   **在`delete`一个对象时首先会调用析构函数**

   使用`delete`时可以释放`NULL`指针,**但不可以对同一个指针释放两次,这样会导致程序崩溃**

# 第四节课

## 引用(reference)

引用是一个安全的指针(可以看作对**相同变量的不同命名**), **引用必须在定义时初始化,并且初始化之后不能再改变引用对象,是永久绑定问题**

1. 引用可以取代通过指针改变参数值的操作

   ```C++
   void fun1(int *i) {
       (*i)++;
   }
   void fun2(int &i) {		// 当函数以引用作为参数时,传参时将引用绑定参数
       i++;
   }
   int main() {
       int m = 10;
       fun1(&m);	// fun1传入m的地址,即指针
       fun2(m);	// fun2传入m
       // 两个函数运行之后m值都是11
   }
   ```

2. 类中隐含存在的不只是默认构造

   还有**拷贝构造** : 即以自身同类型的自身实例作为参数的构造方法,其实现是对参数进行**浅拷贝**形成一个新的对象

   **拷贝构造的传入一般设置为`const`类型的指针**

   深拷贝与浅拷贝 : 

   * 浅拷贝 : 每个对象默认的拷贝形式,**按位拷贝,即拷贝对象数域中的每个字节,当数据域中有指针时浅拷贝大概率会出错**

     注 : **浅拷贝时不会考虑静态的数据成员,因为理论上静态成员不是属于对象自己的,而是整个类公有的**

   * 深拷贝: 逻辑拷贝,要显式的编写 :

     拷贝构造的规则 : 
     
     1. 首先是构造函数 : 与类名相同,无返回值
     2. **其参数类型是确定的,参数只有一个并且一定是本类型的引用对象**
     
     **如果显式的重载了默认构造函数自己实现深拷贝,则一定要相应的重载`=`运算符**
     
   * **拷贝函数的使用场景** :

     1. 显式的调用拷贝构造 :

        `Object o1(o2)`

     2. **当使用一个已有的对象向初始化一个对象时,即出现`=`赋值** :

        `Objext o1 = o2`

     3. **当一个函数的参数时一个对象时 : 由于`C++`也是值传递,所以在调用参数时会建立一个临时对象,这个临时对象就是通过从传入参数进行拷贝构造完成的,在函数调用完出该临时对象的声明周期,所以该对象消亡**

        ```c++
        void use_object(Object o);
        int main() {
            Object a;
            use_object(a);
        }
        ```

        该调用发生了如下流程 : 

        1. 使用**拷贝构造**新建一个对象`c` : `Object c(a)`
        2. 在函数中使用`c`对象
        3. 函数执行完毕之后**调用析构函数**使对象消亡

   ```C++
   Test {
       int i;
       int *j;
   }
   Test::Test(int i, int j) {
       this.i = i;
       this.j = &j;
   }
   Test::~Test() {
       delete j;
   }
   int main() {
       Test t1(1, 2);
       Test t2(t1);	//默认浅拷贝,所以t2.j与t1.j指向同一个地址
   }
   // 当main函数结束时从栈中局部变量弹出消亡,先弹出t2,执行t2的析构函数释放j指向空间
   // 之后弹出t1,执行析构函数,对j指向的同一地址二次释放会崩溃
   
   // 显式的深拷贝
   Test::Test(const Test &t) {
       this.i = t.i;
       this.j = new int(*(t.j));
   }
   ```

3. 指针的错误 :

   * 访问/释放野指针
   * 对同一内存区域重复释放
   * 不同指针指向同一地址(浅拷贝导致)
   * 返回局部变量地址
   * 不及时清理堆上空间导致内存泄漏

4. C/C++`是一次编写,跨平台编译,之后运行

   `java`是一次编译,在任何平台的Java虚拟机上运行,`java`天生带有跨平台特性

# 第五节课

**对参数传递对象一定不要传值(never pass by value)**

## 可见周期/生存周期

1. `static` : 

   * 修饰变量 : 静态变量在局部定义时,其可见域是该局部区域,但是其生存周期是整个程序的运行期

     **静态(局部)变量的存储位置是在全局变量处的,而不在栈区**

     静态局部变量只建立一次,在第一次被使用时建立,在程序运行结束之后消亡

     全局变量在执行函数之前就建立.

   * 修饰函数 : 静态函数默认只能在本文件中使用,一般是一些本文件的功能函数,不允许其他文件调用

     一般函数默认的使用域为全体文件,只需在使用前显示声明即可(**函数默认外连接**)

   * 类中使用 : 

     * 修饰属性 : 静态属性属于类的全体对象,所有对象共享一块内存区域

       **其初始化不应该在构造函数中,而应该在函数外以全局变量的形式初始化**

       **静态的类中属性可以用于实现同一类的所有对象的通信**

     * 修饰方法 : 静态方法可以不通过实例化对象调用,可以直接通过类名来调用

       **这种方法常用于方法返回值与对象属性无关(即不依赖于实例对象)或者一些功能性的函数**

2. 全局变量

   * 全局变量一定在某个源文件中定义,**不能在头文件中定义**(否则头文件被多个源文件包含时会有重复定义)
   * **全局变量默认只能在定义它的源文件中使用**,在其他处使用`extern type elem`显式声明外链接

3. `namespace`:

   * 使用场景 : 当不同的头文件中定义重名时在同一文件包含用来区分同名

   * 实现 : 在`.h`文件中定义名空间,在源文件中使用名空间

     ```c
     // 在H1.h中
     #ifndef _H1_
     #define _H1_
     
     namespace T1 {
         Class name{
             
         }
     }
     #endif
     
     // 在C1.c中
     #include<H1.h>
     int main() {
         T1::name();
     }
     ```

4. `const`

   * 注意在和指针这种复合类型同时使用时注意顶层`const`与底层`const`的区别

     记忆 : 指针就是顶层(所以顶层为指针为常量),指针指向的对象为底层(所以底层意味着指向常量对象)

     当修饰一般的类型时没有区分,均表示该变量在声明时赋值,之后不可改变(可认为是顶层`const`)

     如何在定义中区分顶层与底层 : **常量符`const`与指针符`*`的相对位置,从内向外一层层拆分***
   
     * 底层`const` : 声明**指向常量**的指针,表示**指针认为它指向的是一个常量,所以它自觉的不会去改动他,即不能通过`*point = n`的形式去改变指针指向的值,但是指针指向的对象自身不一定要是常量(即不一定要`const`修饰**
   
       ```c++
       int a = 1;
       int const *p_a = &a; //*p_a表示指针,int const表示指向常量int值
       *p_a = 2;	//该操作是非法的,因为p_a认为自己指向的是常量
       ```
   
       **在通过拷贝赋值时要求有相同或者可转化(右边非常量向左边常量转化)的底层`const`结构,顶层`const`不影响**
   
     * 顶层`const` : **代表指针自身为常量不可修改其存储的地址值, 这意味着在定义该指针时就要赋初值**
   
       ```c++
       int b = 1;
       int *const p_b = &b; // *const p_b表示是自身为常量的指针,int表示指向的是整数
       p_b = &a;	//该操作是非法的,因为该指针为常量,不能改变其值
       ```
   
   * `const`修饰的地址参数一定是在函数中是输入(**只读**),不进行改变
   
   * `const`在函数名之后修饰可以声明常量对象可调用的方法(**该函数不能对对象有所改变**),
   
     1. 常量对象可以调用常量方法
     2. 常量对象不能调用其他非常量方法
     3. 非常量对象也可以调用常量方法
     
     ```c++
     class Obj {
         int i;
     public :
         int get_i() const {
             return i;
         }
     }
     int main() {
         const Obj obj;
         obj.get_i();
     }
     ```

# 第六节课

## 单例模式的实现

使得一个类只允许声明一个实例对象

1. 构造方法私有,防止外部调用
2. 类内部维护一个静态方法来返回唯一实例,**通过类名调用获取唯一对象实例**
3. **该对象实例只有在第一次调用获取静态方法时实例化创建唯一对象**

```c++
class Obj{
    Obj(){}		// 私有构造方法
    static Obj *self = NULL;	// 唯一实例对象指针
public :
    static Obj *get_instance() {	// 获取唯一对象函数
        if (self == NULL) {
            self = new Obj();
        }
        return self;
    }   
}
```

## 运算符重载

对已有的运算符赋予新的含义

```c++
class Account {
    int balance;
public :
    Account();
    Account operator+(int money) {		// 对+进行重载,表示向账户中存钱
        balance += money;
        return *this;
    }
}

int main() {
    Account a;
    a = a + 100;
}
```

**重载的核心在于符合人的逻辑,例如字符串的+重载为字符串拼接操作**

## `new - delete   vs   malloc - free`

* 使用`malloc - free` : 
  1. 预先不知道所需内存大小 : 例如链表的构建
* 使用`new - delete` : 
  1. 动态分配人为控制声明周期
* **`new = malloc + constructor(构造方法)`**
  1. 即`new`操作是在先在堆区分配空间,再调用构造方法
* **`delete = destructor(析构函数) + free`**
  1. 即`delete`操作是先调用析构函数,再释放堆中的动态空间
* 使用核心在于两对成对操作.

## 继承

1. `C++`中继承语法

   ```c++
   class FatherObj{			// 所有子类的共性
   public :
       void doSomething(){
           /*
           code in common
           */
       }
   }
   class SonObj : public FatherObj {			// 特性
   public :
       void doSomething() {
           FatherObj::doSomething();	// 实现共同的行为
           /*
           code in special
           */
       }
   }
   ```


# 第7节课

## 继承

![img](https://images2015.cnblogs.com/blog/1069650/201704/1069650-20170409095256425-2086508779.png)

1. **继承的种类** :
   ![1557066794437](C:\Users\fjh\AppData\Roaming\Typora\typora-user-images\1557066794437.png)

   注意  :

   * **不管是哪种继承方式,在派生类内部都可以访问基类的公有成员和保护成员,基类的私有成员存在但是在子类中不可见(不能访问)**,上表所描述的是子类继承的父类成员**对于子类之外访问的可见性**
   * 不限定时**默认是`private`继承**

2. 重定义 : 子类重载与父类完全相同的方法,即相同的函数名称,相同的参数列表

   ​		**一般按逻辑来说子类重定义方法的首先就要调用父类的方法,这是父子类关系决定的**

3. **基类与派生类之间的关系**

   * 派生类需要添加自己的构造函数

     1. 创建派生类对象时，程序首先创建基类对象；
     2. 要通过初始化表用基类的构造函数给继承过来的成员变量提供初始值；
     3. 如果省略了基类的初始化表，程序会使用基类的默认构造函数；
     4. 也应初始化派生类新增的数据成员；

     注 : **初始化表**  : 一种形式的构造函数

     ```c++
     class object {
         private:
         	int a;
         	int b;
         public:
     		object(int x, int y) : a(x), b(y)
     }
     ```

     **使用情景** :

     1. 替换简单的构造函数
     2. **当数据成员是`const`修饰时只能使用初始化列表初始化**
     3. **当数据成员是引用类型的话只能使用初始化列表初始化**

   * 派生类对象过期时，首先调用派生类的析构，再调用基类的析构；

   * 派生类应根据需要添加自己的成员变量和方法；

   **在继承中的初始化列表可以有派生类显式的决定调用父类的哪一种构造方法**

4. **创建子类对象必然先调用父类的构造方法(默认调用子类的默认构造方法,可用初始化列表显式的指出)**

   **子类消亡时先调用自己的析构函数,再调用父类的析构函数**

   二者顺序时相反的

   ```c++
   class animal{
   public:
       animal() {
           height = 0;
           weight = 0;
       }
   　　animal(int height,int weight){
   　　　　cout<<"animal construct"<<endl;
   　　}
   };
    
   class fish:public animal{
   public:
       fish()	//调用基类的默认无参构造方法animal()
   　　fish():animal(400,300){	//显式指明调用基类的构造方法
   　　　　cout<<"fish construct"<<endl;
   　　}
   };
   ```

5. **能传递父类参数的一定可以传递子类参数,所以在定义参数时尽可能的抽象**

### 成员函数与继承

1. 父类将他的成员函数分为两类 :

   * 希望子类直接继承不要改变的函数
   * **希望子类根据自身特点自行覆盖的函数,即虚函数,使用`virtual`关键字来声明**

   注 : **当使用指针或引用来调用虚函数时该调用被动态绑定根据具体类型来执行**

2. 任何构造函数之外的非静态函数都可以是虚函数

3. **派生类继承基类成员函数的规则** :

   ★ 对于父类函数（virtual、非virtual），如果子类没有同名函数，则正常继承

   ★ 对于父类函数（virtual、非virtual），如果子类有同名函数，无同型函数，则不能调用父类函数(此时实现函数的重写)

   ★ 对于父类函数（virtual、非virtual），如果有同型函数：

   * 非virtual函数由指针类型决定调用哪个
   * virtual函数由指针指向的对象本身决定调用哪个（运行时决定）**这是多态机制的体现**

### 访问控制与继承

* 子类继承父类的成员,但是不一定有权访问,可以访问公有的,不能访问私有的
* `protected`关键词可以使得子类可以访问父类中成员

### 定义子类

使用**类派生列表**

C++支持继承多个父类,但是最好不要调用

```c++
class son : public father {    
}
```

### 子类的组成

**一个子类对象包含多个组成部分** :

* 一个含有自己定义的非静态成员的子对象
* 一个与该子类继承的父类对应的子对象

即子类对象中含有与父类对应的组成部分,如果不显式的在子类的构造方法中调用父类的构造方法,则会调用父类的默认构造方法

### 继承与静态成员

如果一个父类定义了一个静态成员,则在整个继承体系中不敢继承了多少层,**该静态成员只存在唯一的实例**

### 防止继承发生

使用`final`关键词定义类表示其不能被继承

# 第七节课

1. 纯虚函数

   ```c++
   virtual void pure_virtual_function() = 0;
   ```

   **当一个类中有纯虚函数时该类就是抽象类,抽象类不允许实例化**

   纯虚函数也允许有函数结构体

   抽象类的所有子类要想可以实例化必须实现纯虚函数,如果不实现则该子类仍是抽象类

2. 不同类家族之间的关系

   具有共同的功能但是自身在不同的类的继承树中的情况 : **使用接口的机制**

   在`c++`中允许多继承,所以接口本质上就是一个**所有方法都是纯虚函数的抽象类**

   在使用这个共有功能时传入的参数是**这个接口的抽象类型**

   **接口的本质是依赖于行为共性而关联不同家族树上的类,注意,由于其依赖的是行为(即方法),所以设计接口时接口不应该有任何数据成员属性**

   ```c++
   class Bird : public Animal, public FlyObject
   {
       public:
       void fly(){}
   }
   class Airplane : public Machine, public FlyObject
   {
       public:
       void fly(){}
   }
   class FlyObject
   {
       public:
       virtual void fly(){}
   }
   class radar
   {
       public:
       void findFlyObject(FlyObject f){}
   }
   ```

3. 构造析构于多态
   1. 构造函数一定没有多态机制,即构造函数一定不会被`virtual`修饰

   2. 父类的析构函数要支持多态性,否则当参数为父类类型,但是传递进入的是子类类型时可能只调用了父类的析构函数,但是没有调用子类的析构函数,导致内存少泄露

      **所以好的原则是习惯性的将析构函数设置为虚函数**

      ```c++
      class Farher
      {
          public:
      	Father();
          virtual ~Father(){
              cout << "father die" << endl;
          }
      }
      class Son
      {
          public:
      	Son();
          virtual ~Son(){
              cout << "son die" << endl;
          }
      }
      ```

4. 多态一般不用于静态函数,因为**多态保证的行为的正确性,而静态方法与对象本身无关,所以不用使用多态**

5. 栈的数据结构 : **支持泛型的数据结构**,不关心栈中存储的具体数据类型

   ```c++
   template <class T>	//该类是一个模板类
   class Stack<>
   {
       T stack[100];
       int top;
       public:
       	Stack()
       	void push(T elem){}
       	T pop(){}
   }
   //使用时
   Stack<int> stack_int;
   stack_int.push(3)
   Stack<float> stack_float;
   stack_float.puhs(3.2)
   ```

   泛型支持万能容器的构造

   **万能容器实现在`stl`标准库中,其中的类均是标准模板库**

   1. 万能容器
      1. `vector` : 模仿的是动态数组,所以要求地址空间是连续的,**所以当加入的对象多于数组大小是数组会搬家,即进一次整体的拷贝,寻找一个更大的连续空间**
      2. `list` : 模仿的是链表,其中元素的存储是离散的
   2. 动态增长

6. 迭代器 :

   迭代器是个类,`stl`中的所有容器都要支持`begin() & end()`两个方法

   ```c++
   vector<int> vi;
   vector<int>::iterator it = vi.begin();
   while(it != vi.end) {
       cout << *it << endl;
       // do something
       it++;
   }
   //迭代器通过重载运算符(++/*等等)来将自己的行为伪装成一个指针
   ```

   