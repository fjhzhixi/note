# Linux常用命令 

**man + 指令名 可以获取指令相关的帮助信息**

`clear`清屏

## 文件操作

### 查看文件夹内容

`ls [选项].. [文件夹]..` : `list directory contents`

常用选项:

* [-a] : 显示以`.`开头的隐藏文件
* [-l] : 每个文件显示一行的详细信息

### 新建文件目录

`mkdir [选项].. [目录名]..` : 在当前目录下创建文件夹

### 新建文件

`touch [文件名]`

### 删除文件

* 删除**空**文件目录 : `rmdir [选项].. [目录名].. ` : 注意只能删除空文件目录

* 删除目录或文件 : `rm [选项].. [文件/目录路径]*   //(可同时删除多个)`

  常用选项:

  * [-f] : 略过所有不存在的文件,不显示信息,强制删除
  * [-r] : 删除该目录下的所有子目录
  * [-i] : 进行任何删除之前首先确认

  **当确定要删除时 : `rm -rf [file/floder name]`** 可以删除任何文件或文件目录

### 查看文件内容

`cat [选项] [文件] `

[-n] : 对所有输出行编号

### 文件(夹)复制

`cp [选项] 源文件 目标文件`

`-r` : 递归复制文件夹中的所有文件

### 文件(夹)剪切

`mv [选项] 源文件 目标文件`  

-r` : 递归剪切文件夹中的所有文件

### 查找文件

* `find [filename]`: 在当前文件目录之下递归查找文件,返回查找到的路径名

* `grep [选项] pattern file` : 在文件(夹)中查找符合正则表达式的行并打印出来

  `-i` : 忽略字符大小写差异

  `-n` : 显示行号

  `-r`: 递归在文件夹中查找(可以在其子目录下查找)

  `-v`: 反向查找,打印不匹配的项

  注 : 默认匹配的情况只是包含字符串即可,当用`^ $`的锚点时要求全局匹配

### 比较文件

`diff [选项] [file1name] [file2name]` :

选项:

* `-b` : 不检查空格
* `-B` : 不检查空行
* `-q` : 不输出详细信息

## 切换目录

`cd [路径名]` 

- **`.`表示当前目录, `..`表示父目录**

  `cd . : 进入当前目录           cd .. : 进入父目录`

## echo命令

`echo` : 在Shell中打印Shell变量的值,或直接将字符串输出,即输出echo命令的参数

* `echo + >/>> [filename]` : echo命令+重定向输出 : 向文件中写入字符串
  * `>` : 将前面命令的返回值覆盖性输出到filename的文件中(如果没有则新建)
  * `>>` : 追加性输出


## 文件处理工具

### `sed`工具

使用格式 : `sed [选项]  '命令'  目标文本 `

* 选型 : 

  1. `-n` : 安静模式, 默认下目标文本的所有内容都会输出,使用`-n`选项可以使仅输出`sed`的处理对象
  2. `-e` : 当使用多个`sed`命令时在中间连接`sed [option] ‘command1’ -e ‘command2’ [filename]`
  3. `-i` : 直接更改文本内容而不是输出(默认所有命令都是输出而不是改变原有文件)

* 命令 : 

  格式 : `'/pattern/action'` :

  ​	  `pattern`参数表示要匹配哪些行				

    	`action`参数表示对匹配结果的每一行的操作

  **当不写`pattern`参数是默认对所有行进行`action`操作**

  `action`选项:

  1. `p` : 

     * 将匹配`pattern`的行打印出来

     * 结合**定址**操作进行 : 

       `sed -n ‘4p’ [filename]`打印第四行

       `sed -n ‘3,6p’ [filename]` 打印3到6行

       `sed -n ‘/start/, /end/p’ [filename]` : 打印包含`start`的行到包含`end`的行的内容

  2. `d` : 默认形式下只是不打印匹配的行,**不对文件本身进行操作**

     在`-i`形式下删除文件内容

  3. * `s/pattern1/pattern2` : 查找匹配pattern的行,将该行的**第一个**匹配`pattern1`的字符串替换成`pattern2`
     * `s/patten1/pattern2/g` : 对所有成功匹配的进行替换(`global`)

     **注意**:

     * 在`pattern2`中可以用`&`表示与`pattern1`匹配的字符段
     * `pattern2`缺省默认为空串
     * `pattern2`中的`/n`表示与`pattern1`第n个匹配的内容	

  4. `a` : 在当前行后面追加新一行,`sed "[n]a[str]"`在第n行之后插入str, **默认`$`代表该文件最后一行**

  5. `i` : 在当前行之前插入一行

  6. `c` : 用此字符之后的新的文本替换匹配行的文本

* **注意** :
  **在`sed`中的打印`p`功能中使用正则表达式时所有字符(除了`\, ^, $`)都默认表示自身的含义,要表示正则表达式中的特殊含义时要进行转义**

  例如 : `1+`匹配`1+`,而`1/+`匹配出现一次以上的1

  `^[str]$`只能匹配一整行

  **而在`s`功能中已经规定为正则表达式形式,所以可以识别特殊字符**

## shell脚本

`#!/bin/bash` : 在文件开头约定的标记,表示该文件是通过bash运行

### shell变量

* **定义变量初始化注意变量名与`=`之间不能有空格**
* 使用变量时要前置`$`,使用`{}`将变量名划定范围
* `readonly [name]`: 设置变量只读
* 使用字符串变量时:
  * 单引号: **单引号内部所有字符串都是原样输出的,所有不能包含变量名**
  * 双引号: 双引号内可以有变量名,也可以有转义字符
  * 对字符串的操作 :
    * `${#string}` : 获取字符串长度
    * `${string} [char]` `:  获取char字符在string中的位置

### 数组操作

只支持一维的数组类型

* 数组定义

  `arrayName = {value0, value1, value2....}`

  可以使用不连续的下标,且下标无范围

* 获取数组元素

  `${arrayName[index]}`

* 获取数组元素个数

  `${#arrayName[*/@]`

* 获取数组单个元素的长度

  `${arrayName[iindex]}`

### 数据流

* 输入流 : `stdin`,由0表示
* 输出流 : `stdout`, 由1表示
* 标准错误流: `stderr`, 由2表示
  * 使用`command < fileIn`将本来从标准输入中读取转换为从`fileIn`文件读取
  * 使用`command > fileOut`将本来输出到标准输出的输出到`fileOut`文件中

### 管道符号

`command1 | command2 | command3 .....`

将`command1`的`stdout`发给`command2`的`stdin`

### 参数

用`$n`表示第n个参数

* 默认`$0`表示命令本身

* `$#` 表示传递参数的个数

* `"$*"`一个字符串表示传递的所有参数`"args[1], args[2], args[3] ..."`

  `"$@"`以多个字符串表示传递的参数`“args[1]”, “args[2]”, “args[3]” ...`

  

### 逻辑结构(流程控制)

逻辑运算要用`[]`包含

* ```shell
  if condition
  then
  	command1
  	command2
  	........
  else		# 可有可无
  fi
  
  if condition1
  then
  	commands1
  elif condition2
  then 
  	commands2
  ......
  fi
  
  # 逻辑运算符
  -eq		# ==
  -ne		# !=
  -gt		# >
  -lt		# <
  -ge 	# >=
  -le		# <=
  # 注意逻辑结构表达式要用中括号包括,并且运算数与运算符之间要有空格
  ex:
  if [ $a -eq $b]
  then
  	echo "$a != $b"
  fi
  # 或与的逻辑实现
  # 与:
  1. if [ $a -eq $b -a $a -eq $b ]
  2. if [[ $a -eq $b && $a -eq $b ]]
  # 或:
  1. if [ $a -eq $b -o $a -eq $b ]
  2. if [[ $a -eq $b || $a -eq $b ]]
  
  ```

* ```shell
  while condition
  do
  	commands
  done
  ```

* ```shell
  for var in item1 item2 item3 .... itemN
  do
  	command
  done
  ```

* ```bash
  case var in
  var1):
  	commands1
  	break
  	;;
  var2):
  	command2
  	break
  	;;
  ......
  esac
  ```

* 

### 运算操作

* 算术运算符:

  使用`expr`进行运算

  ```bash
  val=`expr $a + $b`
  val=`expr $a - $b`
  val=`expr $a \* $b`		# 乘号*要进行转义
  val=`expr $a / $b`
  ```

  注意:

  * **运算数和运算符之间必须要有空即`$a + $b`三者之间必须要有空格**
  * **`=`和两个表达式之间不要有空格**

### echo命令

* 显示字符串,最好用双引号,可以子字符串中使用转义字符,也可以输出变量值
* 可是使用`>`将输出重定向写入到文件中去
* echo默认自动添加换行符
  * 也可以使用`printf`命令进行
  * `printf “format-string” [arguments]`

### test命令

可以用来比较变量,字符串是否相等,也可以比较文件

### shell函数

* 函数定义:

  ```shell
  function functName()
  	commands
  	......
  	return []
  ```

* 函数调用

  `functName args1 args2...`

* 不定义return的默认返回式最后一条语句的运行结果

* 在函数中使用参数和向脚本中传递参数式一个模式

### 包含文件

* `. [文件路径]` : 例如`. ./test.sh`包含当前文件夹下的test.sh脚本
* `source [文件路径]`

## Makefile

组织代码编译的文件