# Linux常用命令 

**man + 指令名 可以获取指令相关的帮助信息**

`clear`清屏

## 文件操作

### 查看文件夹内容

`ls [选项].. [文件夹]..` : `list directory contents`

常用选项:

* [-a] : 显示以`.`开头的隐藏文件
* [-l] : 每个文件显示一行的详细信息

### 新建文件目录

`mkdir [选项].. [目录名]..` : 在当前目录下创建文件夹

### 新建文件

`touch [文件名]`

### 删除文件

* 删除**空**文件目录 : `rmdir [选项].. [目录名].. ` : 注意只能删除空文件目录

* 删除目录或文件 : `rm [选项].. [文件/目录路径]*   //(可同时删除多个)`

  常用选项:

  * [-f] : 略过所有不存在的文件,不显示信息,强制删除
  * [-r] : 删除该目录下的所有子目录
  * [-i] : 进行任何删除之前首先确认

  **当确定要删除时 : `rm -rf [file/floder name]`** 可以删除任何文件或文件目录

### 查看文件内容

`cat [选项] [文件] `

[-n] : 对所有输出行编号

### 文件(夹)复制

`cp [选项] 源文件 目标文件`

`-r` : 递归复制文件夹中的所有文件

### 文件(夹)剪切

`mv [选项] 源文件 目标文件`  

-r` : 递归剪切文件夹中的所有文件

### 查找文件

* `find [filename]`: 在当前文件目录之下递归查找文件,返回查找到的路径名

* `grep [选项] pattern file` : 在文件(夹)中查找符合正则表达式的行并打印出来

  `-i` : 忽略字符大小写差异

  `-n` : 显示行号

  `-r`: 递归在文件夹中查找(可以在其子目录下查找)

  `-v`: 反向查找,打印不匹配的项

  注 : 默认匹配的情况只是包含字符串即可,当用`^ $`的锚点时要求全局匹配

### 比较文件

`diff [选项] [file1name] [file2name]` :

选项:

* `-b` : 不检查空格
* `-B` : 不检查空行
* `-q` : 不输出详细信息

## 切换目录

`cd [路径名]` 

- **`.`表示当前目录, `..`表示父目录**

  `cd . : 进入当前目录           cd .. : 进入父目录`

## echo命令

`echo` : 在Shell中打印Shell变量的值,或直接将字符串输出,即输出echo命令的参数

* `echo + >/>> [filename]` : echo命令+重定向输出 : 向文件中写入字符串
  * `>` : 将前面命令的返回值覆盖性输出到filename的文件中(如果没有则新建)
  * `>>` : 追加性输出


## 文件处理工具

### `sed`工具

使用格式 : `sed [选项]  '命令'  目标文本 `

* 选型 : 

  1. `-n` : 安静模式, 默认下目标文本的所有内容都会输出,使用`-n`选项可以使仅输出`sed`的处理对象
  2. `-e` : 当使用多个`sed`命令时在中间连接`sed [option] ‘command1’ -e ‘command2’ [filename]`
  3. `-i` : 直接更改文本内容而不是输出(默认所有命令都是输出而不是改变原有文件)

* 命令 : 

  格式 : `'/pattern/action'` :

  ​	  `pattern`参数表示要匹配哪些行				

    	`action`参数表示对匹配结果的每一行的操作

  **当不写`pattern`参数是默认对所有行进行`action`操作**

  `action`选项:

  1. `p` : 

     * 将匹配`pattern`的行打印出来

     * 结合**定址**操作进行 : 

       `sed -n ‘4p’ [filename]`打印第四行

       `sed -n ‘3,6p’ [filename]` 打印3到6行

       `sed -n ‘/start/, /end/p’ [filename]` : 打印包含`start`的行到包含`end`的行的内容

  2. `d` : 默认形式下只是不打印匹配的行,**不对文件本身进行操作**

     在`-i`形式下删除文件内容

  3. * `s/pattern1/pattern2` : 查找匹配pattern的行,将该行的**第一个**匹配`pattern1`的字符串替换成`pattern2`
     * `s/patten1/pattern2/g` : 对所有成功匹配的进行替换(`global`)

     **注意**:

     * 在`pattern2`中可以用`&`表示与`pattern1`匹配的字符段
     * `pattern2`缺省默认为空串
     * `pattern2`中的`/n`表示与`pattern1`第n个匹配的内容	

  4. `a` : 在当前行后面追加新一行,`sed "[n]a[str]"`在第n行之后插入str, **默认`$`代表该文件最后一行**

  5. `i` : 在当前行之前插入一行

  6. `c` : 用此字符之后的新的文本替换匹配行的文本

* **注意** :
  **在`sed`中的打印`p`功能中使用正则表达式时所有字符(除了`\, ^, $`)都默认表示自身的含义,要表示正则表达式中的特殊含义时要进行转义**

  例如 : `1+`匹配`1+`,而`1/+`匹配出现一次以上的1

  `^[str]$`只能匹配一整行

  **而在`s`功能中已经规定为正则表达式形式,所以可以识别特殊字符**

## shell脚本

### 数据流

* 输入流 : `stdin`,由0表示
* 输出流 : `stdout`, 由1表示
* 标准错误流: `stderr`, 由2表示

### 管道符号

`command1 | command2 | command3 .....`

将`command1`的`stdout`发给`command2`的`stdin`

### 参数

用`$n`表示第n个参数

* 默认`$0`表示命令本身
* `$#` 表示传递参数的个数
* `$*`一个字符串表示传递的所有参数

### 逻辑结构

* ```shell
  if condition
  then
  	command1
  	command2
  	........
  fi
  # 逻辑运算符
  -eq		# ==
  -ne		# !=
  -gt		# >
  -lt		# <
  -ge 	# >=
  -le		# <=
  ```

* ```shell
  while condition
  do
  	commands
  done
  ```

## Makefile

组织代码编译的文件