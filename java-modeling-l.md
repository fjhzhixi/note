# JML规格

实现的**设计**必须满足**规格**的要求

## 基本语法

**一般对一个属性/方法的规格描述在其紧邻的上方**

### 原子表达式

1. `\result` : 表示一个非`void`方法的返回值
2. `\old(expr)` : 表示一个表达式`expr`在方法执行前的值
   * 注意 : 当`expr`为一个引用对象时**只表示引用对象的地址值,不代表引用对象的引用值**
3. `\not_assigned(x,y,...) ` : 表示括号内的各个变量在方法前后没有改变(被赋值)
4. `\typeof(expr) ` : 返回`expr`的数据类型,用来判断是否等于`\type(type[int/boolean....])` 

### 量化表达式

1. 全称量词 : `\forall`表达式

   使用 : `\forall int i; P(i) ; P` 在`i`满足`P(i)`时,必须由`P`逻辑为真

   即在给定范围内的元素要保证`P`恒为真

2. 存在量词 : `\exists `表达式

   使用 : `\exists int i; P(i); P`

   即在给定范围内至少存在一个元素使`P`为真

3. 求和 : `\sum` 表达式

   使用 : `\sum int i; P(i); n(i)`

   即求给定范围内的某一类数据的和

4. 计数 : `num_of` 表达式

   使用 : `num_of int i; P(i); P`

   即求给定范围内满足`P`逻辑的元素个数

### 操作符

1. `==>` : 蕴含操作符,逻辑同离散数学中

   使用 : `expr1 ==> expr2` :

   1. 当`expr1`为真时,`expr2`为真时整个表达式为真,否则为假
   2. 当`expr1`为假时,整个表达式为真

## 分析阶段

针对于类中的属性与方法从**逻辑**上分析出**行为规范约束**

### 对属性

对类中的每个属性成员,分析:

1. 在**可见状态**下必须满足的**不变特性**
2. 在一次值变化时必须要满足的**状态变化约束**

注 : 

1. 可见状态指的是属性的值时稳定的,当处于所有会修改成员变量的值的方法内部时都是不可见状态
2. **在该层次分析的是属性成员必须在任何行为中满足的基本约束条件,不考虑细节,只是宏观的类决定的逻辑层次**

### 对方法

对类中的每个定义的方法,分析:

1. **输入参数**要求 : **前置条件**

   将所有输入的范围划分为**不重合**的区间,划分依据如下 :

   * 从方法正常执行的逻辑上要求**调用者**必须满足的输入条件
   * 多种**不合法的输入**分别抛出不同类型的异常

   注 : 最好可以做到是一个**划分**,即对所有可能输入的全覆盖

2. **返回值**要求 : **后置条件**

   要求**方法实现者**确保方法执行的结果一定要满足的条件

   注 : 

   1. 显式的针对于不是`void`类型的方法,其他方法也有隐含的后置条件,不在返回值体现,在其他方面体现
   2. **后置条件满足的前提是调用者满足正确输入的前置条件**

3. **实现过程**要求 : **副作用限定** :

   对方法实现过程中是否可以对对象的属性进行改变的限定

## 实现阶段

实现从逻辑上分析出来的约束条件的**建模层次**的**描述**

### 对属性

使用**类型规格语法**来描述

注 : 由于安全性要求的**私有属性对外部不可见**使用`spec_public`来标记在`JML`中可见

1. 不变特性 : 使用**不变式`invariant P`**描述

   `p`为描述属性在**可见状态**下的约束条件的**布尔表达式**

   例 :

   ```java
   public class Path{
   	private /*@spec_public@*/ ArrayList <Integer> seq_nodes;
   	private /*@spec_public@*/ Integer start_node;
   	private /*@spec_public@*/ Integer end_node;
   	/*@ invariant seq_nodes != null &&
   	  @ seq_nodes[0] == start_node &&
   	  @ seq_nodes[seq_nodes.legnth-1] == end_node &&
   	  @ seq_nodes.length >=2;
   	  @*/
   }
   ```

   注 : **可以实现一个函数`boolean repOK()`用来检查某一时刻的属性是否满足不变式,方便测试**

   1. 例如可以在每次更新之前来检查满足不变式

2. 状态变化约束 : 使用**状态变化约束`constraint P`**来描述

   `p`为描述属性**当前可见状态和前序可见状态的关系**的**布尔表达式**

   例 :

   ```java
   public class ServiceCounter{
   	private /*@spec_public@*/ long counter;
   	//@ invariant counter >= 0;
   	//@ constraint counter == \old(counter)+1;
   }
   ```

### 对方法

使用**方法规格语法**来描述

1. 对输入参数使用**前置条件语法`requires P`**来描述

   `P`为方法输入参数在**某一区间**满足的**布尔表达式**

2. 对返回值使用**后置条件语法`ensures P`**来描述

   `P`为方法**正常执行**时输出满足的**布尔表达式**\

   **后置条件约束的可能形式** :

   1. 通过显示的`return`和`throw`来返回结果 : 

      * `return`使用`ensure + P(\result)`来描述约束
      * `throw`使用`signals (***Exception e) b_expr `来描述约束

   2. 通过修改所在`this`对象的状态返回结果

      使用`ensure + P(this)`来描述约束

   3. 通过修改方法的输入参数的内容来返回结果

      使用`ensure + P(args)`来描述约束

   注 : **后置条件约束是构造性的,即不要描述生成结果的算法,只需描述结果的自己的性质(从数学角度来描述)即可**

3. 对实现过程使用**副作用范围限定语法`assignable / modifiable  elems`**来描述

   `assignable`表示可赋值的,`modifiable`表示可修改的,`elems`为其描述对象,即一个变量列表

注 :

1. 对**异常**的处理 : 

   使用`signals`语句来描述可能抛出异常

   **根据输入分一个正常执行描述,若干个异常描述处理** : 

   * 使用`public normal_behavior`接下来的描述正常执行
   * 使用`public exceptional_behavior`接下来的描述异常行为
   * 不同段之间使用`also`连接

2. **层次化的描述规格** :

   * 引用依赖对象中的`public`的数据规格来描述

   * **借用已定义的`pure`**方法来描述 :

     `pure`方法的要求

     1. 无副作用
     2. **任何情况下都有结果**,即正常结束或者抛出异常,不会陷入内部死循环
     3. 规格逻辑比较简单

例 :

```java
/*@ public normal_behavior
@ requires z <= 99;
@ assignable \nothing;
@ ensures \result > z;
@ also
@ public exceptional_behavior
@ requires z < 0;
@ assignable \nothing;
@ signals (IllegalArgumentException e) true;
@*/
public abstract int cantBeSatisfied(int z) throws IllegalArgumentException;
```

## 继承下的规格设计

### 数据

1. 在继承下不能修改父类的数据规格
2. 在继承下子类可以规定自己的独有数据并设定规格

### 方法

**首先构造方法保证父类与子类的数据有效性恒成立**

在继承下其他有三种规格的情况 :

1. 直接继承父类的方法不做修改 : 子类不需要考虑,该方法的规格正确性有父类保证
2. 自己定义自己独有的方法 : 子类设定自己的规格要求并实现
3. **子类重写父类的规格** : **首先要求规格的定义不能矛盾,即要求符合`LSP`原则**,具体:
   * **前置条件 : 子类只能减弱父类的前置条件(即范围可以放宽但是不能缩小)**
   * **后置条件 : 子类只能加强父类的后置条件(即增加(`&&`)更多条件)**

注 : **当子类不能直接访问父类属性(即父类都为`private`无`protected`),只能通过父类满足规格(即一定保证数据有效性)的方法来访问数据时数据有效性很容易维护**



